# ⏰ 浏览器模式超时修复说明

## 问题现象

评论爬取时，浏览器模式获取签名超时（30秒）：

```
2025-11-22 22:48:11 - 🚀 调用签名服务浏览器模式
2025-11-22 22:48:42 - ❌ 浏览器模式请求超时(30s)，降级到纯JS模式
```

## 根本原因

Playwright 等待拦截目标请求时，请求没有被正确触发或拦截，导致：
1. **请求未发出** - `_triggerRequest` 中的 fetch 可能失败
2. **请求未拦截** - 路由监听没有捕获到请求
3. **等待时间不足** - 原来只等待 5 秒（10 次 × 500ms）

## 修复方案

### 1. 改进 `_triggerRequest` 方法

**之前**（简单版）：
```javascript
async _triggerRequest(url, method, data) {
  const script = `
    (async () => {
      const response = await fetch('${url}', options);
      return await response.json();
    })();
  `;
  await this.page.evaluate(script);
}
```

**现在**（详细版）：
```javascript
async _triggerRequest(url, method, data) {
  console.log(`🚀 触发请求: ${method} ${url}`);
  
  const result = await this.page.evaluate(async ({ url, method, data }) => {
    try {
      const options = { method, headers: {...}, credentials: 'include' };
      if (data) options.body = JSON.stringify(data);
      
      console.log(`[页面内] Fetch 选项:`, options);
      const response = await fetch(url, options);
      console.log(`[页面内] 响应状态: ${response.status}`);
      
      return { success: true, status: response.status };
    } catch (error) {
      console.error(`[页面内] 请求失败:`, error.message);
      return { success: false, error: error.message };
    }
  }, { url, method, data });
  
  if (result.success) {
    console.log(`✅ 请求触发成功`);
  } else {
    console.warn(`⚠️ 请求触发失败: ${result.error}`);
  }
}
```

**改进点**：
- ✅ 添加详细的控制台日志
- ✅ 捕获页面内的错误
- ✅ 返回执行结果
- ✅ 支持调试

### 2. 增加等待时间

**之前**：
```javascript
let retries = 0;
while (!this.interceptedHeaders && retries < 10) {  // 10 次 = 5 秒
  await this._sleep(500);
  retries++;
}
```

**现在**：
```javascript
let retries = 0;
const maxRetries = 30;  // 30 次 = 15 秒
while (!this.interceptedHeaders && retries < maxRetries) {
  await this._sleep(500);
  retries++;
  
  if (retries % 5 === 0) {
    console.log(`⏳ 等待中... (${retries}/${maxRetries})`);
  }
}
```

**改进点**：
- ✅ 等待时间从 5 秒增加到 15 秒
- ✅ 添加进度提示（每 2.5 秒输出一次）
- ✅ 明确显示等待次数

### 3. 并发执行和错误处理

```javascript
// 触发请求（不阻塞）
const triggerPromise = this._triggerRequest(targetUrl, method, data);

// 等待拦截
while (!this.interceptedHeaders && retries < maxRetries) {
  await this._sleep(500);
  retries++;
}

// 确保 trigger 完成
try {
  await triggerPromise;
} catch (err) {
  console.warn(`⚠️ 触发请求时出错: ${err.message}`);
}

if (!this.interceptedHeaders) {
  throw new Error(`未能捕获到目标请求头 (等待了 ${retries * 0.5} 秒)`);
}
```

## 诊断工具

创建了 `test_detail_sign.js` 用于单独测试详情接口：

```bash
cd signature-service
node test_detail_sign.js
```

**输出示例**：
```
╔════════════════════════════════════════╗
║  测试详情接口签名获取                  ║
╚════════════════════════════════════════╝

📋 测试参数:
   note_id: 68303bbb000000002100f85c
   URL: https://edith.xiaohongshu.com/api/sns/web/v1/note/detail
   Method: POST

🚀 触发请求: POST https://edith.xiaohongshu.com/api/sns/web/v1/note/detail
[页面内] Fetch 选项: { method: 'POST', ... }
[页面内] 响应状态: 200
✅ 请求触发成功

⏳ 等待中... (5/30)
✅ 匹配到目标请求: https://edith.xiaohongshu.com/api/sns/web/v1/note/detail
✅ 已捕获目标请求头
✅ 成功捕获请求头 (用时 3.5 秒)

✅ 成功获取请求头 (用时 4.2 秒):
   x-s: XYS_2UQhPsHCH0c1Pjh9...
   x-t: 1763822112910
   x-s-common: 2UQAPsHC+aIjqArjwj...
   x-b3-traceid: c6bef63bca9dc83a

✅ 所有必需的请求头都已获取!
```

## 验证步骤

### 1. 确保 Electron 运行

```bash
cd frontend
npm run dev
```

检查调试端口：
```bash
curl http://localhost:9222/json/version
```

### 2. 重启签名服务

```bash
cd signature-service
npm run dev
```

### 3. 运行诊断脚本

```bash
cd signature-service
node test_detail_sign.js
```

**成功标志**：
- ✅ 用时 < 10 秒
- ✅ 所有签名头都有值
- ✅ 没有超时错误

**失败标志**：
- ❌ 超时 (> 25 秒)
- ❌ 签名头为空
- ❌ CDP 连接错误

### 4. 测试后端爬取

```bash
cd backend
python main.py
```

创建一个搜索任务并启用评论爬取，观察日志：

**预期日志**：
```
✅ 搜索到 20 条笔记: 劳动
🔑 笔记 xxx 缺少 xsec_token，正在从详情页获取...
🚀 触发请求: POST .../note/detail
✅ 请求触发成功
⏳ 等待中... (5/30)
✅ 成功捕获请求头 (用时 4.5 秒)
✅ 成功获取并缓存 xsec_token: xxx
💬 正在获取评论: xxx
✅ 成功爬取评论: xxx (15 条)
```

## 性能分析

### 时间分解

单次详情接口签名获取：
- **连接 Electron**: ~0.5s
- **触发请求**: ~1-2s
- **等待拦截**: ~1-3s
- **返回数据**: ~0.5s
- **总计**: 3-6 秒（正常）

如果超过 10 秒，说明有问题。

### 优化建议

1. **复用浏览器连接**
   - 不要每次都重新连接 Electron
   - 在任务级别保持连接

2. **预加载机制**
   - 批量获取 note_id 列表
   - 并发请求多个详情接口

3. **降级策略**
   - 如果详情接口超时，尝试从搜索结果中提取 token
   - 如果仍然失败，跳过该笔记

## 故障排查

### 问题 1: 仍然超时 30 秒

**可能原因**：
1. Electron 窗口没有加载小红书页面
2. 网络很慢，页面加载超时
3. 调试端口连接不稳定

**解决方法**：
```bash
# 1. 检查 Electron 是否正常
curl http://localhost:9222/json

# 2. 查看 Electron 窗口
# 确保小红书登录窗口已经打开并加载完成

# 3. 手动测试
# 在 Electron 中手动访问一个笔记详情页
# 确认页面可以正常加载
```

### 问题 2: 请求触发失败

日志显示：
```
⚠️ 请求触发失败: Failed to fetch
```

**可能原因**：
- Cookie 无效或过期
- 页面 CSP 限制
- 小红书 API 变更

**解决方法**：
1. 重新登录获取新 Cookie
2. 检查账号状态
3. 查看小红书网页版是否能正常访问

### 问题 3: 拦截不到请求

日志显示：
```
✅ 请求触发成功
⏳ 等待中... (30/30)
❌ 未能捕获到目标请求头 (等待了 15 秒)
```

**可能原因**：
- 路径匹配规则有问题
- 请求被重定向或修改
- Playwright 路由监听失效

**解决方法**：
1. 检查签名服务日志，查看是否有 "⏭️ 忽略非目标请求" 的输出
2. 如果有，说明路径没匹配上，需要调整匹配逻辑
3. 尝试放宽匹配条件：
   ```javascript
   // 临时：匹配所有 /note/detail 请求
   if (url.includes('/api/sns/web/v1/note/detail')) {
     this.interceptedHeaders = request.headers();
   }
   ```

## 后续优化

1. **智能重试**
   - 第一次失败时，等待 2 秒后重试
   - 最多重试 2 次

2. **连接池**
   - 维护一个 Playwright 连接池
   - 避免频繁连接/断开 Electron

3. **缓存预热**
   - 在任务开始时，批量获取所有 token
   - 存入 Redis，有效期 1 小时

---

📅 修复时间: 2025-11-22  
🔖 版本: V2.3  
👤 修复人: AI Assistant


